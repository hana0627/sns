package com.hana.sns.mock

import com.hana.sns.post.domain.Post
import com.hana.sns.post.service.port.PostRepository
import com.hana.sns.user.domain.User
import org.springframework.data.domain.Page
import org.springframework.data.domain.PageImpl
import org.springframework.data.domain.Pageable
import java.util.concurrent.atomic.AtomicLong

class FakePostRepository : PostRepository {
    private val autoGeneratedId: AtomicLong = AtomicLong(0)
    var data = mutableListOf<Post>()
    override fun save(post: Post): Post {
        if(post.id == 0 || post.id == null) {
            post.id = autoGeneratedId.incrementAndGet().toInt()
            data.add(post)
        } else {
            data.removeIf { it.id == post.id }
            post.id = autoGeneratedId.incrementAndGet().toInt()
            data.add(post)
        }
        return post
    }

    override fun findById(id: Int): Post? {
        return data.find { it.id == id }
    }

    override fun delete(post: Post) {
        data.removeIf{it == post }
    }

    override fun findAll(pageable: Pageable): Page<Post> {
        val pageSize = pageable.pageSize
        val offset = pageable.offset.toInt()

        // 페이지 시작 / 끝 index 추가
        // TODO 추가학습 coerceAtMost??
        val startIndex = offset.coerceAtMost(data.size - 1)
        val endIndex = (offset + pageSize).coerceAtMost(data.size)

        // TODO sublist?? 중간 사이값 추출
        val sublist = data.subList(startIndex, endIndex)

        return PageImpl(sublist, pageable, data.size.toLong())

    }

    override fun findAllByUser(pageable: Pageable, user: User): Page<Post> {
        val pageSize = pageable.pageSize
        val offset = pageable.offset.toInt()

        val startIndex = offset.coerceAtMost(data.size - 1)
        val endIndex = (offset + pageSize).coerceAtMost(data.size)

        val sublist = data.filter { it.user == user }.subList(startIndex, endIndex)

        return PageImpl(sublist, pageable, data.size.toLong())

    }

    fun findAll(): List<Post> {
        return data
    }

}
